# 如何实现一个靠谱的协议

客户端每发送一个包，服务器端都应该有个回复，如果服务器端超过一定时间没有回复，客户端就会重新发包，直到有回复



## 串行发送

上一个收到了应答，再发下一个。

这种模式的缺点是效率比较低，如果一方处理的时间较长，另一方就会长时间等待



## 并行发送

预设一个buffer，发送端同时发送多条数据包，接收端并行得接收，在接收端接收的过程中，发送端还可以增发数据包，从而实现双方的并行交互，此是双方都需要buffer来记录数据收发的状态





# TCP协议解决顺序问题和丢包问题

TCP协议利用序号和重发机制结合收发双方的buffer解决顺序问题和丢包问题



## 收发buffer状态

![image-20211111231524967](/home/gaoxiang/.config/Typora/typora-user-images/image-20211111231524967.png)

TCP协议使用并行收发的形式，为了保证顺序性，每个包都有一个ID，在建立连接的时候，会商定起始ID是什么，然后按照ID一个个发送

为了保证不丢包，对于发送的包都要进行应答，但这个应答也不是一个个来的，而是会应答某个之前的ID，彪是都收到了，这种模式称为**累计确认**或**累计应答**

如上例子：

1、2、3没有问题，双方达成一致

4、5接收方说ACK了，但是发送方还没收到，有可能丢了，有可能还在路上

6、7、8、9发送方肯定已经发送，但8、9已经到了，但是6、7还没到，出现了乱序，缓存着但是没办法ACK

假设4的ACK到了发送端，但是5的ACK丢包了，6、7的数据包丢了，这该怎么办呢？

超时重试：也即对每一个发送了，但每收到ACK的包，都设置一个定时器，超过了一定时间，就重新尝试

这个时间不宜过短，时间必须大与**往返时间RTT**，否则会引起不必要的重传，也不宜过长，这样超时时间边唱，访问变慢



## 自适应重传算法

估计往返时间，需要TCP通过采样RTT的时间然后做加权平均，算出一个值，这个值是不断变化的，随着网络状况的变化，除了采样RTT，还要采样RTT的波动范围（即公差），计算出一个估计的超时。

由于重传时间不断变化，称为**自适应重传算法（Adaptive Retransmission Algorithm）**



如果过了一段时间5、6、7都超时了，就会重新发送。

接收方发现5原来接受过，于是丢弃5

6收到了，发送ACK，要求下一个是7，但7又丢了，当7在此超时的时候，又需要重传，TCP的测罗是超时间隔加倍

每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍

两次超时，就说明网络环境差，不宜频繁重复发送



## 快速重传机制

当接收方收到一个序号大与下一个所期望的报文段时，就会检测到数据流中的一个间隔，于是它就会发送冗余的ACK，仍然ACK的是期望接收接收的报文段。而当客户端收到三个冗余的ACK后，就会在定时器过期之前，重传丢失的报文段

例如：接收方发现6收到了，8也收到了，但是7没收到，那肯定是丢了，于是发送6的ACK，要求下一个是7

接下来收到后续的包，仍然发送6的ACK，要求下一个是7

当客户端收到3个重复ACK，就会发现7确实丢了，不等超时，马上重发



## SACK

另一种同步方式为Selective Acknowledgment（SACK），这种方式需要在报文中增加一个SACK的东西，可以将缓存的地图发送给发送方（按位存储状态）